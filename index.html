<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0" />
    <title>Today's Music</title>
    <style>
        .long {
            width: 70%;

        }

        body {
            margin: 5% auto;
            background: #f2f2f2;
            color: #444444;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 16px;
            line-height: 1.8;
            text-shadow: 0 1px 0 #ffffff;
            max-width: 73%;
        }

        code {
            background: white;
        }

        a {
            border-bottom: 1px solid #444444;
            color: #444444;
            text-decoration: none;
        }

        a:hover {
            border-bottom: 0;
        }
    </style>
</head>

<body>
    <header>
        <h1>Today's Music &#9836;</h1>
        <aside></aside>
    </header>
    <h2><strong>The ideia</strong></h2>
    <p>It is incredibly hard to find new music out there, the recommendations algorithms are so well-made that true
        option is just not there anymore. With that in my mind (and probably some grains of caffeine) I made a Spotify
        scrapper that extract a good amount of music on a daily basis. This allows people (mostly developers) to search
        by themself and find new stuff.</p>

    <h2>The datasets</h2>
    <p>They are generated daily on this bucket. You can always find the latest one here.<br />Just beware that since
        this is a backyard project, there is no standad yet and the format may vary.
    </p>
    <h2>Let's have some fun</h2>

    <p>If you click on the button bellow it will
    <ol>
        <li>Grab the latest dataset</li>
        <li>Ask you to put some target music codes</li>
        <li>Ask how many musics you will want on your playlist</li>
        <li>The hamsters on your computer will do some magic (basic math really)</li>
        <li>Badabin, badabon, a new playlist will appear on your screen</li>

    </ol>
    <code>Beware that it make computations on your browser and on really low end machines this may cause the tab to crash</code>
    </p>

    <button onclick="fun()">Do the fun stuff</button>

    <div id="fun" style="display:none">
        <h2>The fun</h2>
        <p2>What do you want to input?</p2><br />
        <button onclick="with_playlist()">I have a playlist</button> <button onclick="with_music()">I have some
            musics</button><br><br>
        <div id="with_playlist" style="display:none">
            <p>Okay, then:<br />
            <ol>
                <li>Go to your playlist on spotify</li>
                <li>Click on the three dots</li>
                <li>Click in share</li>
                <li>Copy the link</li>
                <li>Paste the link on the box bellow</li>
            </ol>
            <input id="playlist_id" class="long"><button onclick="generate_based_on_playlist()">Generate my
                playlist</button>
            </p>
        </div>
        <div id="with_music" style="display:none">
            <p>Okay, then:<br />
            <ol>
                <li>Go the music on spotify</li>
                <li>Click on the three dots</li>
                <li>Click in share</li>
                <li>Copy the link</li>
                <li>Paste the link on one of the boxes bellow</li>
            </ol>
            <ol>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
            </ol>
            <br>
            <button onclick="generate_based_on_musics()">Generate my playlist</button>
            </p>
        </div>
    </div>

    <div id="your_playlist" style="display: none">
        <h2>Yay, here is your playlist ◖ᵔᴥᵔ◗ ♪ ♫</h2>

    </div>
    <h2>What we can and what we cannot do</h2>
    <p>This project requires serverside computation, and serverside computation require me paying for it. In order of
        making it afordable, I'll only go as far as displaying the playlist on the screen. <br />I have another page
        ready that creates the playlist on <b>your</b> spotidy account, but that will only happen if this project
        recieves some donations and it is able to sustain itself.</p>
    <hr>
    <h2>If you want to help</h2>

    <footer>
        If you want to donate to keep this project alive, clike here<br />
        If you want to contribute with the project, take a look at the ToDo list<br />
        Made by Supitto, website template stolen from <a
            href="https://github.com/setetres/evenbettermotherfuckingwebsite">this repository</a>.</p>
    </footer>
    <script>
        document.dataset = []

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fun() {
            
            dirty_dataset = await fetch("https://todays-music.s3.sa-east-1.amazonaws.com/latest.json").then(r => r.json())
            
            not_null = dirty_dataset.filter(val => val != null)
            mapped_dataset = {}
            not_null.forEach(element => {
                mapped_dataset[element['id']] = element
            });
            
            document.dataset = Object.keys(not_null).map(v => mapped_dataset[v])
            
            document.querySelector("#fun").style.display = "";
        }

        const with_playlist = () => {
            document.querySelector("#with_playlist").style.display = "";
            document.querySelector("#with_music").style.display = "none";
        }

        const with_music = () => {
            document.querySelector("#with_music").style.display = "";
            document.querySelector("#with_playlist").style.display = "none";
        }

        const generate_based_on_musics = () => {
            let centroids = [
                {
                    'liveness': 0.7,
                    'valence': 0.1
                },
                {
                    'liveness': 0.1,
                    'valence': 0.4
                },
                {
                    'liveness': 1,
                    'valence': 0
                },

            ]
            generate_playlist(centroids, document.dataset)
        }


        async function generate_based_on_playlist() {
            let id = document.querySelector("#playlist_id").value.split('?')[0].split('/').at(-1)
            let tracks = await fetch("https://mjmkhaspb5.execute-api.sa-east-1.amazonaws.com/return_features_from_playlist", { method: "POST", body: '{"id": "' + id + '"}' }).then(r => r.json())
            let centroids = find_centroids(tracks['audio_features'])
            generate_playlist(centroids, document.dataset)
        }

        const find_centroids = (dataset) => {
            let centroids_and_scores = Array.from(Array(Math.ceil(Math.min(20, dataset.length / 2))).keys()).slice(2).map((v) => train_k_means_and_return_centroids(v, dataset))
            let max_score = centroids_and_scores[0].score
            centroids_and_scores.reduce((acc, cur) => {
                cur.value = cur.value / max_score
                return acc.concat(cur)
            }, [])
            return return_best_centroids(centroids_and_scores) //centroids_and_scores[3].centroids
        }

        const generate_playlist = (dataset, centroids) => {
            d = document.querySelector("#your_playlist")

            tracks = find_closest(dataset, centroids)
            embeddeds = tracks.reduce((a, v) => a + generate_embedded(v), "")

            d.innerHTML += embeddeds
            sleep(2000)
            d.style.display = "";
        }

        const powered_distance = (track, centroid) => {

            let l = track["liveness"] - centroid["liveness"];
            l = l * l;

            let v = track["valence"] - centroid["valence"]
            v = v * v;

            return { 'id': track['id'], 'score': v + l }
        }

        const find_closest = (centroids, dataset) => {
            let var1 = dataset.filter(v => v != null)
            let var2 = var1.map(track => centroids.map(centroid => powered_distance(track, centroid)).sort((a, b) => a['score'] - b['score'])[0])
            let var3 = var2.sort((a, b) => a['score'] - b['score'])
            let var4 = var3.slice(0, 20);
            return var4;
        }

        const generate_embedded = (obj) => {
            return '<iframe src="https://open.spotify.com/embed/track/' + obj['id'] + '" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><br>'
        }

        // this is a simple kmeans implementation

        const train_k_means_and_return_centroids = (number_of_clusters, dataset) => {
            centroids = generate_centroids(number_of_clusters)
            do {
                old_centroids = copy_centroids(centroids)
                labeled_dataset = fit(centroids, dataset)
                centroids = ajust_centroids(labeled_dataset)
            } while (is_centroid_movement_small_enough(centroids, old_centroids) == false)
            let wss = calculate_wss(centroids, labeled_dataset)

            return { centroids: centroids, score: wss }
        }

        const calculate_wss = (centroids, labeled_dataset) => {
            centroid_map = {}
            centroids.forEach(element => {
                centroid_map[element['label']] = element
            });
            return labeled_dataset.reduce((acc, val) => acc + powered_distance(val, centroid_map[val['label']])['score'], 0)
        }

        const generate_centroids = (n) => Array.from(Array(n).keys()).reduce((acc, val) => acc.concat({ valence: Math.random(), liveness: Math.random(), label: val, id: 'dummy' }), [])

        const fit = (centroids, dataset) => {

            return dataset.map((tuple) => {
                let tmp = centroids.map((centroid) => {
                    let aaaaa = powered_distance(tuple, centroid)
                    aaaaa['label'] = centroid['label']
                    return aaaaa
                })
                let tmp2 = tmp.sort((a, b) => a['score'] - b['score'])
                tuple['label'] = tmp2[0]['label']
                return tuple
            })
        }

        const copy_centroids = (c) => c.map(v => { return { valence: v['valence'], liveness: v['liveness'], label: v['label'], id: 'dummy' } })

        const ajust_centroids = (dataset) => {
            groups = dataset.reduce((acc, val) => {
                if (val['label'] in acc) {
                    acc[val['label']].push(val)
                } else {
                    acc[val['label']] = [val]
                }
                return acc
            }, {})

            return Object.keys(groups).map((key) => groups[key].reduce((acc, val) => {
                acc['valence'] += val['valence'] / groups[key].length
                acc['liveness'] += val['liveness'] / groups[key].length
                return acc
            }, { valence: 0, liveness: 0, label: key }));

        }

        const is_centroid_movement_small_enough = (c1, c2) => {
            small = true
            for (let index = 0; index < c1.length; index++) {
                small = small && powered_distance(c1[index], c2[index]).score < 0.0025
            }
            return small
        }

        const return_best_centroids = (elbow_points) => {

            points = elbow_points.map((val, index) => {
                return { x: index, y: val.score, label: index }
            })

            translated_points = points.map(val => {
                tx = val.x - points.at(-1).x
                ty = val.y - points.at(-1).y
                return { x: tx, y: ty, label: val.label }
            })

            h = Math.sqrt(Math.pow(translated_points.at(0).x - translated_points.at(-1).x, 2) + Math.pow(translated_points.at(0).y - translated_points.at(-1).y, 2))
            a = translated_points.at(-1).x - translated_points.at(0).x
            o = translated_points.at(0).y - translated_points.at(1).y
            s = o/h
            c = a/h

            rotated_points = translated_points.map(val => {
                return {
                    x: (- c * val.x) - (-s * val.y),
                    y: (- s * val.x) + (-c * val.y),
                    label: val.label
                }
            })
            best_centroid = {centroids: [], score: 0}
            rotated_points.forEach(element => {
                if(element.y > best_centroid.score){
                    best_centroid = {
                        centroids: elbow_points[element.label].centroids,
                        score: element.y
                    }
                }
            });
            return best_centroid.centroids

        }


    </script>
</body>

</html>