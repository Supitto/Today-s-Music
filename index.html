<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0" />
    <title>Today's Music</title>
    <style>
        .long {
            width: 70%;

        }

        body {
            margin: 5% auto;
            background: #f2f2f2;
            color: #444444;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 16px;
            line-height: 1.8;
            text-shadow: 0 1px 0 #ffffff;
            max-width: 73%;
        }

        code {
            background: white;
        }

        a {
            border-bottom: 1px solid #444444;
            color: #444444;
            text-decoration: none;
        }

        a:hover {
            border-bottom: 0;
        }
    </style>
</head>

<body>
    <header>
        <h1>Today's Music &#9836;</h1>
        <aside></aside>
    </header>
    <h2><strong>The ideia</strong></h2>
    <p>It is incredibly hard to find new music out there, the recommendations algorithms are so well-made that true
        option is just not there anymore. With that in my mind (and probably some grains of caffeine) I made a Spotify
        scrapper that extract a good amount of music on a daily basis. This allows people (mostly developers) to search
        by themself and find new stuff.</p>

    <h2>The datasets</h2>
    <p>They are generated daily on this bucket. You can always find the latest one here.<br />Just beware that since
        this is a backyard project, there is no standad yet and the format may vary.
    </p>
    <h2>Let's have some fun</h2>

    <p>If you click on the button bellow it will
    <ol>
        <li>Grab the latest dataset</li>
        <li>Ask you to put some target music codes</li>
        <li>Ask how many musics you will want on your playlist</li>
        <li>The hamsters on your computer will do some magic (basic math really)</li>
        <li>Badabin, badabon, a new playlist will appear on your screen</li>

    </ol>
    <code>Beware that it make computations on your browser and on really low end machines this may cause the tab to crash</code>
    </p>

    <button onclick="fun()">Do the fun stuff</button>

    <div id="fun" style="display:none">
        <h2>The fun</h2>
        <p2>What do you want to input?</p2><br />
        <button onclick="with_playlist()">I have a playlist</button> <button onclick="with_music()">I have some
            musics</button><br><br>
        <div id="with_playlist" style="display:none">
            <p>Okay, then:<br />
            <ol>
                <li>Go to your playlist on spotify</li>
                <li>Click on the three dots</li>
                <li>Click in share</li>
                <li>Copy the link</li>
                <li>Paste the link on the box bellow</li>
            </ol>
            <input id="playlist_id" class="long"><button onclick="generate_based_on_playlist()">Generate my
                playlist</button>
            </p>
        </div>
        <div id="with_music" style="display:none">
            <p>Okay, then:<br />
            <ol>
                <li>Go the music on spotify</li>
                <li>Click on the three dots</li>
                <li>Click in share</li>
                <li>Copy the link</li>
                <li>Paste the link on one of the boxes bellow</li>
            </ol>
            <ol>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
                <li><input class="long" id="music_id"></li>
            </ol>
            <br>
            <button onclick="generate_based_on_musics()">Generate my playlist</button>
            </p>
        </div>
    </div>

    <div id="your_playlist" style="display: none">
        <h2>Yay, here is your playlist ◖ᵔᴥᵔ◗ ♪ ♫</h2>

    </div>
    <h2>What we can and what we cannot do</h2>
    <p>This project requires serverside computation, and serverside computation require me paying for it. In order of
        making it afordable, I'll only go as far as displaying the playlist on the screen. <br />I have another page
        ready that creates the playlist on <b>your</b> spotidy account, but that will only happen if this project
        recieves some donations and it is able to sustain itself.</p>
    <hr>
    <h2>If you want to help</h2>

    <footer>
        If you want to donate to keep this project alive, clike here<br />
        If you want to contribute with the project, take a look at the ToDo list<br />
        Made by Supitto, website template stolen from <a
            href="https://github.com/setetres/evenbettermotherfuckingwebsite">this repository</a>.</p>
    </footer>
    <script>
        document.dataset = []

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fun() {
            document.querySelector("#fun").style.display = "";
            document.dataset = await fetch("https://todays-music.s3.sa-east-1.amazonaws.com/latest.json").then(r => r.json())
        }

        const with_playlist = () => {
            document.querySelector("#with_playlist").style.display = "";
            document.querySelector("#with_music").style.display = "none";
        }

        const with_music = () => {
            document.querySelector("#with_music").style.display = "";
            document.querySelector("#with_playlist").style.display = "none";
        }

        const generate_based_on_musics = () => {
            let centroids = [
                {
                    'liveness': 0.7,
                    'valence': 0.1
                },
                {
                    'liveness': 0.1,
                    'valence': 0.4
                },
                {
                    'liveness': 1,
                    'valence': 0
                },

            ]
            generate_playlist(centroids, document.dataset)
        }


        async function generate_based_on_playlist() {
            let id = document.querySelector("#playlist_id").value.split('?')[0].split('/').at(-1)
            console.log(id)
            let tracks = await fetch("https://mjmkhaspb5.execute-api.sa-east-1.amazonaws.com/return_features_from_playlist", { method: "POST", body: '{"id": "' + id + '"}' }).then(r => r.json())
            console.log(tracks)
            let centroids = train_k_means_and_return_centroids(5,tracks['audio_features'])
            generate_playlist(centroids, document.dataset)
        }

        const generate_playlist = (dataset, centroids) => {
            d = document.querySelector("#your_playlist")

            tracks = find_closest(dataset, centroids)
            embeddeds = tracks.reduce((a, v) => a + generate_embedded(v), "")

            d.innerHTML += embeddeds
            sleep(2000)
            d.style.display = "";
        }

        const powered_distance = (track, centroid) => {

            let l = track["liveness"] - centroid["liveness"];
            l = l * l;

            let v = track["valence"] - centroid["valence"]
            v = v * v;

            return { 'id': track['id'], 'score': v + l }
        }

        const find_closest = (centroids, dataset) => {
            let var1 = dataset.filter(v => v != null)
            let var2 = var1.map(track => centroids.map(centroid => powered_distance(track, centroid)).sort((a, b) => a['score'] - b['score'])[0])
            let var3 = var2.sort((a, b) => a['score'] - b['score'])
            let var4 = var3.slice(0, 20);
            return var4;
        }

        const test = () => {
            let centroids = [
                {
                    'liveness': 0.7,
                    'valence': 0.1
                },
                {
                    'liveness': 0.1,
                    'valence': 0.4
                },
                {
                    'liveness': 1,
                    'valence': 0
                },

            ]
            console.log(find_closest(centroids, d))
        }

        const generate_embedded = (obj) => {
            return '<iframe src="https://open.spotify.com/embed/track/' + obj['id'] + '" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><br>'
        }

        // this is a simple kmeans implementation

        const train_k_means_and_return_centroids = (number_of_clusters, dataset) => {
            centroids = generate_centroids(number_of_clusters)
            do{
                old_centroids = copy_centroids(centroids)
                labeled_dataset = fit(centroids,dataset)
                centroids = ajust_centroids(labeled_dataset)
            }while(is_centroid_movement_small_enough(centroid,old_centroids) == false)
            return centroids
        }

        const generate_centroids = (n) => Array.from(Array(n).keys()).reduce((acc,val) => acc.concat({valence: Math.random(), liveness: Math.random(),label: val, id: 'dummy'}), [])

        const fit = (centroids, dataset) => {
            
            return dataset.map((tuple) => {
                tuple['label'] = centroids.map((centroid) => powered_distance(tuple, centroid)).sort((a, b) => a['score'] - b['score'])[0]['label']
                return tuple
            })
        }

        const copy_centroids = (c) => {return {valence: c['valence'], liveness: c['liveness'],label: c['label'], id:'dummy'}}

        const ajust_centroids = (dataset) => {
            groups = dataset.reduce((acc,val) => {
                if(acc.keys.includes(val['label'])){
                    acc[val['label']].push(val)
                } else {
                    acc[val['label']] = [val]
                }
                return acc
            })

            return Object.keys(groups).map((key) => groups[key].reduce((acc,val) => {
                acc['valence'] += val['valence']/groups[key].length
                acc['liveness'] += val['liveness']/groups[key].length
            },{valence:0, liveness:0, label:key}));

        }

        const is_centroid_movement_small_enough = (c1, c2) => {
            small = true
            for (let index = 0; index < c1.length; index++) {
                small = small && powered_distance(c1[i],c2[i]).score < 0.0025
            }
            return small
        }
    </script>
</body>

</html>